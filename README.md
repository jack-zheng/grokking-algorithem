# grokking-algorithem

Reading note of grokking algorithem

## Chapter 01: 算法简介

二分查找，时间复杂度 O(log<sup>n</sup>)

1. 有序元素列表
1. 有则返回结果，没有则返回null

对数是幂运算的逆运算

大O表示法指出了最糟情况下的运行时间

常见的几种大O运行时间：

1. O(log<sup>n</sup>) 对数时间 - 二分查找
1. O(n) 线性时间 - 简单查找
1. O(n*log<sup>n</sup>) 快速排序 - 较快的排序
1. O(n<sup>2</sup>) 选择排序 - 较慢的排序
1. O(n!) 旅行商问题 - 非常慢

![time complexity](images/time_complexity.png)

* 算法的速度指的并不是时间，而是操作数的增速
* 谈论算法的速度时，我们说的是随着输入的增加，运行时间将以什么样的速度增加
* 算法的运行时间用O表示法表示
* O(log<sup>n</sup>)比O(n)快，当搜索元素越多时，越明显

## Chapter 02: 选择排序

选择排序-O(n<sup>2</sup>): 找出目标元素需要时间O(n)，这种操作需要执行n次。不是很快的一种排序方式

类比冒泡排序：两种排序O相同，但是交换策列不同，选择排序是取一个依次和后面的比，如果符合条件则交换，冒泡的话是如果符合条件，交换相邻的两个元素

## Chapter 03: 递归

递归函数：基线条件(base case) + 递归条件(recursive case)

递归条件：函数调用自己， 基线条件：函数不再调用自己

## Chapter 04: 快速排序

D&C - divide and conquer

例1：168m * 64m 的田地，把他均匀的分成方块，方块尽可能大，最大的变长是多少

例2：使用递归求数组和

例3：快速排序

快排思路：

1. 选区基准值
1. 将数据分成： 小于基准值 + 基准值 + 大于基准值 三类
1. 对小于和大于基准值的类做快排
1. 合并结果

合并排序（merge sort）时间复杂度O(nlogn), 快速排序最坏情况O(n<sup>2</sup>), 但是快排的时间常数要比合并排序小，快排时间复杂度介于O(nlogn) - O(n<sup>2</sup>)之间

对比了一下 java 和 python 的快排实现，python 要好理解不止一点点。。。应为语法上python要简介很多，底层实现和效率就不得而知了
